"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/superstruct";
exports.ids = ["vendor-chunks/superstruct"];
exports.modules = {

/***/ "(ssr)/../node_modules/superstruct/lib/index.es.js":
/*!***************************************************!*\
  !*** ../node_modules/superstruct/lib/index.es.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   StructError: () => (/* binding */ StructError),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   defaulted: () => (/* binding */ defaulted),\n/* harmony export */   define: () => (/* binding */ define),\n/* harmony export */   deprecated: () => (/* binding */ deprecated),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   enums: () => (/* binding */ enums),\n/* harmony export */   func: () => (/* binding */ func),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   nonempty: () => (/* binding */ nonempty),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   pattern: () => (/* binding */ pattern),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   refine: () => (/* binding */ refine),\n/* harmony export */   regexp: () => (/* binding */ regexp),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   trimmed: () => (/* binding */ trimmed),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */ /**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */ class StructError extends TypeError {\n    constructor(failure, failures){\n        let cached;\n        const { message, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : \"At path: \" + path.join(\".\") + \" -- \" + message;\n        super(msg);\n        this.value = void 0;\n        this.key = void 0;\n        this.type = void 0;\n        this.refinement = void 0;\n        this.path = void 0;\n        this.branch = void 0;\n        this.failures = void 0;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = ()=>{\n            var _cached;\n            return (_cached = cached) != null ? _cached : cached = [\n                failure,\n                ...failures()\n            ];\n        };\n    }\n}\n/**\n * Check if a value is an iterator.\n */ function isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === \"function\";\n}\n/**\n * Check if a value is a plain object.\n */ function isObject(x) {\n    return typeof x === \"object\" && x != null;\n}\n/**\n * Check if a value is a plain object.\n */ function isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== \"[object Object]\") {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */ function print(value) {\n    return typeof value === \"string\" ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */ function shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */ function toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    } else if (result === false) {\n        result = {};\n    } else if (typeof result === \"string\") {\n        result = {\n            message: result\n        };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : \"\") + \", but received: `\" + print(value) + \"`\" } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */ function* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [\n            result\n        ];\n    }\n    for (const r of result){\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */ function* run(value, struct, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { path = [], branch = [\n        value\n    ], coerce = false, mask = false } = options;\n    const ctx = {\n        path,\n        branch\n    };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n        if (mask && struct.type !== \"type\" && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n            for(const key in value){\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let valid = true;\n    for (const failure of struct.validator(value, ctx)){\n        valid = false;\n        yield [\n            failure,\n            undefined\n        ];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)){\n        const ts = run(v, s, {\n            path: k === undefined ? path : [\n                ...path,\n                k\n            ],\n            branch: k === undefined ? branch : [\n                ...branch,\n                v\n            ],\n            coerce,\n            mask\n        });\n        for (const t of ts){\n            if (t[0]) {\n                valid = false;\n                yield [\n                    t[0],\n                    undefined\n                ];\n            } else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                } else if (value instanceof Map) {\n                    value.set(k, v);\n                } else if (value instanceof Set) {\n                    value.add(v);\n                } else if (isObject(value)) {\n                    value[k] = v;\n                }\n            }\n        }\n    }\n    if (valid) {\n        for (const failure of struct.refiner(value, ctx)){\n            valid = false;\n            yield [\n                failure,\n                undefined\n            ];\n        }\n    }\n    if (valid) {\n        yield [\n            undefined,\n            value\n        ];\n    }\n}\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */ class Struct {\n    constructor(props){\n        this.TYPE = void 0;\n        this.type = void 0;\n        this.schema = void 0;\n        this.coercer = void 0;\n        this.validator = void 0;\n        this.refiner = void 0;\n        this.entries = void 0;\n        const { type, schema, validator, refiner, coercer = (value)=>value, entries = function*() {} } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context)=>{\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.validator = ()=>[];\n        }\n        if (refiner) {\n            this.refiner = (value, context)=>{\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.refiner = ()=>[];\n        }\n    }\n    /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */ assert(value) {\n        return assert(value, this);\n    }\n    /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */ create(value) {\n        return create(value, this);\n    }\n    /**\n   * Check if a value passes the struct's validation.\n   */ is(value) {\n        return is(value, this);\n    }\n    /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */ mask(value) {\n        return mask(value, this);\n    }\n    /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */ validate(value, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */ function assert(value, struct) {\n    const result = validate(value, struct);\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */ function create(value, struct) {\n    const result = validate(value, struct, {\n        coerce: true\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */ function mask(value, struct) {\n    const result = validate(value, struct, {\n        coerce: true,\n        mask: true\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */ function is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */ function validate(value, struct, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function*() {\n            for (const t of tuples){\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [\n            error,\n            undefined\n        ];\n    } else {\n        const v = tuple[1];\n        return [\n            undefined,\n            v\n        ];\n    }\n}\nfunction assign() {\n    for(var _len = arguments.length, Structs = new Array(_len), _key = 0; _key < _len; _key++){\n        Structs[_key] = arguments[_key];\n    }\n    const isType = Structs[0].type === \"type\";\n    const schemas = Structs.map((s)=>s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */ function define(name, validator) {\n    return new Struct({\n        type: name,\n        schema: null,\n        validator\n    });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */ function deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx),\n        validator (value, ctx) {\n            if (value === undefined) {\n                return true;\n            } else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        }\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */ function dynamic(fn) {\n    return new Struct({\n        type: \"dynamic\",\n        schema: null,\n        *entries (value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */ function lazy(fn) {\n    let struct;\n    return new Struct({\n        type: \"lazy\",\n        schema: null,\n        *entries (value, ctx) {\n            var _struct;\n            (_struct = struct) != null ? _struct : struct = fn();\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            var _struct2;\n            (_struct2 = struct) != null ? _struct2 : struct = fn();\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            var _struct3;\n            (_struct3 = struct) != null ? _struct3 : struct = fn();\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            var _struct4;\n            (_struct4 = struct) != null ? _struct4 : struct = fn();\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */ function omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = {\n        ...schema\n    };\n    for (const key of keys){\n        delete subschema[key];\n    }\n    switch(struct.type){\n        case \"type\":\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */ function partial(struct) {\n    const schema = struct instanceof Struct ? {\n        ...struct.schema\n    } : {\n        ...struct\n    };\n    for(const key in schema){\n        schema[key] = optional(schema[key]);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */ function pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys){\n        subschema[key] = schema[key];\n    }\n    return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */ function struct(name, validator) {\n    console.warn(\"superstruct@0.11 - The `struct` helper has been renamed to `define`.\");\n    return define(name, validator);\n}\n/**\n * Ensure that any value passes validation.\n */ function any() {\n    return define(\"any\", ()=>true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: \"array\",\n        schema: Element,\n        *entries (value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()){\n                    yield [\n                        i,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator (value) {\n            return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */ function bigint() {\n    return define(\"bigint\", (value)=>{\n        return typeof value === \"bigint\";\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */ function boolean() {\n    return define(\"boolean\", (value)=>{\n        return typeof value === \"boolean\";\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */ function date() {\n    return define(\"date\", (value)=>{\n        return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \" + print(value);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v)=>print(v)).join();\n    for (const key of values){\n        schema[key] = key;\n    }\n    return new Struct({\n        type: \"enums\",\n        schema,\n        validator (value) {\n            return values.includes(value) || \"Expected one of `\" + description + \"`, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a function.\n */ function func() {\n    return define(\"func\", (value)=>{\n        return typeof value === \"function\" || \"Expected a function, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */ function instance(Class) {\n    return define(\"instance\", (value)=>{\n        return value instanceof Class || \"Expected a `\" + Class.name + \"` instance, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */ function integer() {\n    return define(\"integer\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */ function intersection(Structs) {\n    return new Struct({\n        type: \"intersection\",\n        schema: null,\n        *entries (value, ctx) {\n            for (const S of Structs){\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator (value, ctx) {\n            for (const S of Structs){\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner (value, ctx) {\n            for (const S of Structs){\n                yield* S.refiner(value, ctx);\n            }\n        }\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: \"literal\",\n        schema: t === \"string\" || t === \"number\" || t === \"boolean\" ? constant : null,\n        validator (value) {\n            return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n        }\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: \"map\",\n        schema: null,\n        *entries (value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()){\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator (value) {\n            return value instanceof Map || \"Expected a `Map` object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */ function never() {\n    return define(\"never\", ()=>false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */ function nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === null || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === null || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is a number.\n */ function number() {\n    return define(\"number\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: \"object\",\n        schema: schema ? schema : null,\n        *entries (value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns){\n                    unknowns.delete(key);\n                    yield [\n                        key,\n                        value[key],\n                        schema[key]\n                    ];\n                }\n                for (const key of unknowns){\n                    yield [\n                        key,\n                        value[key],\n                        Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || \"Expected an object, but received: \" + print(value);\n        },\n        coercer (value) {\n            return isObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */ function optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */ function record(Key, Value) {\n    return new Struct({\n        type: \"record\",\n        schema: null,\n        *entries (value) {\n            if (isObject(value)) {\n                for(const k in value){\n                    const v = value[k];\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || \"Expected an object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */ function regexp() {\n    return define(\"regexp\", (value)=>{\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: \"set\",\n        schema: null,\n        *entries (value) {\n            if (Element && value instanceof Set) {\n                for (const v of value){\n                    yield [\n                        v,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator (value) {\n            return value instanceof Set || \"Expected a `Set` object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a string.\n */ function string() {\n    return define(\"string\", (value)=>{\n        return typeof value === \"string\" || \"Expected a string, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */ function tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: \"tuple\",\n        schema: null,\n        *entries (value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for(let i = 0; i < length; i++){\n                    yield [\n                        i,\n                        value[i],\n                        Structs[i] || Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return Array.isArray(value) || \"Expected an array, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */ function type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: \"type\",\n        schema,\n        *entries (value) {\n            if (isObject(value)) {\n                for (const k of keys){\n                    yield [\n                        k,\n                        value[k],\n                        schema[k]\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || \"Expected an object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */ function union(Structs) {\n    const description = Structs.map((s)=>s.type).join(\" | \");\n    return new Struct({\n        type: \"union\",\n        schema: null,\n        coercer (value, ctx) {\n            const firstMatch = Structs.find((s)=>{\n                const [e] = s.validate(value, {\n                    coerce: true\n                });\n                return !e;\n            }) || unknown();\n            return firstMatch.coercer(value, ctx);\n        },\n        validator (value, ctx) {\n            const failures = [];\n            for (const S of Structs){\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                } else {\n                    for (const [failure] of tuples){\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                \"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value),\n                ...failures\n            ];\n        }\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */ function unknown() {\n    return define(\"unknown\", ()=>true);\n}\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx)=>{\n            return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n        }\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function defaulted(struct, fallback, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return coerce(struct, unknown(), (x)=>{\n        const f = typeof fallback === \"function\" ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = {\n                ...x\n            };\n            let changed = false;\n            for(const key in f){\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function trimmed(struct) {\n    return coerce(struct, string(), (x)=>x.trim());\n}\n/**\n * Ensure that a string, array, map, or set is empty.\n */ function empty(struct) {\n    return refine(struct, \"empty\", (value)=>{\n        const size = getSize(value);\n        return size === 0 || \"Expected an empty \" + struct.type + \" but received one with a size of `\" + size + \"`\";\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    } else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */ function max(struct, threshold, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { exclusive } = options;\n    return refine(struct, \"max\", (value)=>{\n        return exclusive ? value < threshold : value <= threshold || \"Expected a \" + struct.type + \" less than \" + (exclusive ? \"\" : \"or equal to \") + threshold + \" but received `\" + value + \"`\";\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */ function min(struct, threshold, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { exclusive } = options;\n    return refine(struct, \"min\", (value)=>{\n        return exclusive ? value > threshold : value >= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? \"\" : \"or equal to \") + threshold + \" but received `\" + value + \"`\";\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */ function nonempty(struct) {\n    return refine(struct, \"nonempty\", (value)=>{\n        const size = getSize(value);\n        return size > 0 || \"Expected a nonempty \" + struct.type + \" but received an empty one\";\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */ function pattern(struct, regexp) {\n    return refine(struct, \"pattern\", (value)=>{\n        return regexp.test(value) || \"Expected a \" + struct.type + \" matching `/\" + regexp.source + '/` but received \"' + value + '\"';\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */ function size(struct, min, max) {\n    if (max === void 0) {\n        max = min;\n    }\n    const expected = \"Expected a \" + struct.type;\n    const of = min === max ? \"of `\" + min + \"`\" : \"between `\" + min + \"` and `\" + max + \"`\";\n    return refine(struct, \"size\", (value)=>{\n        if (typeof value === \"number\" || value instanceof Date) {\n            return min <= value && value <= max || expected + \" \" + of + \" but received `\" + value + \"`\";\n        } else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return min <= size && size <= max || expected + \" with a size \" + of + \" but received one with a size of `\" + size + \"`\";\n        } else {\n            const { length } = value;\n            return min <= length && length <= max || expected + \" with a length \" + of + \" but received one with a length of `\" + length + \"`\";\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */ function refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner (value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures){\n                yield {\n                    ...failure,\n                    refinement: name\n                };\n            }\n        }\n    });\n}\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3N1cGVyc3RydWN0L2xpYi9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUVEOzs7Ozs7O0NBT0MsR0FDRCxNQUFNQSxvQkFBb0JDO0lBQ3hCQyxZQUFZQyxPQUFPLEVBQUVDLFFBQVEsQ0FBRTtRQUM3QixJQUFJQztRQUNKLE1BQU0sRUFDSkMsT0FBTyxFQUNQLEdBQUdDLE1BQ0osR0FBR0o7UUFDSixNQUFNLEVBQ0pLLElBQUksRUFDTCxHQUFHTDtRQUNKLE1BQU1NLE1BQU1ELEtBQUtFLE1BQU0sS0FBSyxJQUFJSixVQUFVLGNBQWNFLEtBQUtHLElBQUksQ0FBQyxPQUFPLFNBQVNMO1FBQ2xGLEtBQUssQ0FBQ0c7UUFDTixJQUFJLENBQUNHLEtBQUssR0FBRyxLQUFLO1FBQ2xCLElBQUksQ0FBQ0MsR0FBRyxHQUFHLEtBQUs7UUFDaEIsSUFBSSxDQUFDQyxJQUFJLEdBQUcsS0FBSztRQUNqQixJQUFJLENBQUNDLFVBQVUsR0FBRyxLQUFLO1FBQ3ZCLElBQUksQ0FBQ1AsSUFBSSxHQUFHLEtBQUs7UUFDakIsSUFBSSxDQUFDUSxNQUFNLEdBQUcsS0FBSztRQUNuQixJQUFJLENBQUNaLFFBQVEsR0FBRyxLQUFLO1FBQ3JCYSxPQUFPQyxNQUFNLENBQUMsSUFBSSxFQUFFWDtRQUNwQixJQUFJLENBQUNZLElBQUksR0FBRyxJQUFJLENBQUNqQixXQUFXLENBQUNpQixJQUFJO1FBRWpDLElBQUksQ0FBQ2YsUUFBUSxHQUFHO1lBQ2QsSUFBSWdCO1lBRUosT0FBTyxDQUFDQSxVQUFVZixNQUFLLEtBQU0sT0FBT2UsVUFBVWYsU0FBUztnQkFBQ0Y7bUJBQVlDO2FBQVc7UUFDakY7SUFDRjtBQUVGO0FBRUE7O0NBRUMsR0FDRCxTQUFTaUIsV0FBV0MsQ0FBQztJQUNuQixPQUFPQyxTQUFTRCxNQUFNLE9BQU9BLENB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T0EsVUFBVSxZQUFZQSxpQkFBaUJtRyxNQUFNO1lBQ3RELE9BQU9zRCxPQUFPekosU0FBU0EsU0FBU2tJLE9BQU80QixXQUFXLE1BQU1DLEtBQUssb0JBQW9CL0osUUFBUTtRQUMzRixPQUFPLElBQUlBLGlCQUFpQmtELE9BQU9sRCxpQkFBaUJvRCxLQUFLO1lBQ3ZELE1BQU0sRUFDSmlHLElBQUksRUFDTCxHQUFHcko7WUFDSixPQUFPeUosT0FBT0osUUFBUUEsUUFBUW5CLE9BQU80QixXQUFXLGtCQUFrQkMsS0FBSyx1Q0FBdUNWLE9BQU87UUFDdkgsT0FBTztZQUNMLE1BQU0sRUFDSnZKLE1BQU0sRUFDUCxHQUFHRTtZQUNKLE9BQU95SixPQUFPM0osVUFBVUEsVUFBVW9JLE9BQU80QixXQUFXLG9CQUFvQkMsS0FBSyx5Q0FBeUNqSyxTQUFTO1FBQ2pJO0lBQ0Y7QUFDRjtBQUNBOzs7Ozs7Q0FNQyxHQUVELFNBQVNzSixPQUFPdEgsTUFBTSxFQUFFdkIsSUFBSSxFQUFFK0MsT0FBTztJQUNuQyxPQUFPLElBQUlDLE9BQU87UUFBRSxHQUFHekIsTUFBTTtRQUUzQixDQUFDd0IsU0FBUXRELEtBQUssRUFBRXFDLEdBQUc7WUFDakIsT0FBT1AsT0FBT3dCLE9BQU8sQ0FBQ3RELE9BQU9xQztZQUM3QixNQUFNVCxTQUFTMEIsUUFBUXRELE9BQU9xQztZQUM5QixNQUFNN0MsV0FBV3VDLFdBQVdILFFBQVFTLEtBQUtQLFFBQVE5QjtZQUVqRCxLQUFLLE1BQU1ULFdBQVdDLFNBQVU7Z0JBQzlCLE1BQU07b0JBQUUsR0FBR0QsT0FBTztvQkFDaEJZLFlBQVlJO2dCQUNkO1lBQ0Y7UUFDRjtJQUVGO0FBQ0Y7QUFFNlosQ0FDN1osb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zdXBlcnN0cnVjdC9saWIvaW5kZXguZXMuanM/NDQwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgYFN0cnVjdEZhaWx1cmVgIHJlcHJlc2VudHMgYSBzaW5nbGUgc3BlY2lmaWMgZmFpbHVyZSBpbiB2YWxpZGF0aW9uLlxuICovXG5cbi8qKlxuICogYFN0cnVjdEVycm9yYCBvYmplY3RzIGFyZSB0aHJvd24gKG9yIHJldHVybmVkKSB3aGVuIHZhbGlkYXRpb24gZmFpbHMuXG4gKlxuICogVmFsaWRhdGlvbiBsb2dpYyBpcyBkZXNpZ24gdG8gZXhpdCBlYXJseSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS4gVGhlIGVycm9yXG4gKiByZXByZXNlbnRzIHRoZSBmaXJzdCBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgdmFsaWRhdGlvbi4gRm9yIG1vcmUgZGV0YWlsLFxuICogdGhlIGBlcnJvci5mYWlsdXJlc2AgcHJvcGVydHkgaXMgYSBnZW5lcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgcnVuIHRvXG4gKiBjb250aW51ZSB2YWxpZGF0aW9uIGFuZCByZWNlaXZlIGFsbCB0aGUgZmFpbHVyZXMgaW4gdGhlIGRhdGEuXG4gKi9cbmNsYXNzIFN0cnVjdEVycm9yIGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgY29uc3RydWN0b3IoZmFpbHVyZSwgZmFpbHVyZXMpIHtcbiAgICBsZXQgY2FjaGVkO1xuICAgIGNvbnN0IHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IGZhaWx1cmU7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aFxuICAgIH0gPSBmYWlsdXJlO1xuICAgIGNvbnN0IG1zZyA9IHBhdGgubGVuZ3RoID09PSAwID8gbWVzc2FnZSA6IFwiQXQgcGF0aDogXCIgKyBwYXRoLmpvaW4oJy4nKSArIFwiIC0tIFwiICsgbWVzc2FnZTtcbiAgICBzdXBlcihtc2cpO1xuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlID0gdm9pZCAwO1xuICAgIHRoaXMucmVmaW5lbWVudCA9IHZvaWQgMDtcbiAgICB0aGlzLnBhdGggPSB2b2lkIDA7XG4gICAgdGhpcy5icmFuY2ggPSB2b2lkIDA7XG4gICAgdGhpcy5mYWlsdXJlcyA9IHZvaWQgMDtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHJlc3QpO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcblxuICAgIHRoaXMuZmFpbHVyZXMgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NhY2hlZDtcblxuICAgICAgcmV0dXJuIChfY2FjaGVkID0gY2FjaGVkKSAhPSBudWxsID8gX2NhY2hlZCA6IGNhY2hlZCA9IFtmYWlsdXJlLCAuLi5mYWlsdXJlcygpXTtcbiAgICB9O1xuICB9XG5cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGl0ZXJhdG9yLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKHgpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIHR5cGVvZiB4W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKi9cblxuXG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPSBudWxsO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICovXG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoeCkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih4KTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG4vKipcbiAqIFJldHVybiBhIHZhbHVlIGFzIGEgcHJpbnRhYmxlIHN0cmluZy5cbiAqL1xuXG5mdW5jdGlvbiBwcmludCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IFwiXCIgKyB2YWx1ZTtcbn1cbi8qKlxuICogU2hpZnRzIChyZW1vdmVzIGFuZCByZXR1cm5zKSB0aGUgZmlyc3QgdmFsdWUgZnJvbSB0aGUgYGlucHV0YCBpdGVyYXRvci5cbiAqIExpa2UgYEFycmF5LnByb3RvdHlwZS5zaGlmdCgpYCBidXQgZm9yIGFuIGBJdGVyYXRvcmAuXG4gKi9cblxuZnVuY3Rpb24gc2hpZnRJdGVyYXRvcihpbnB1dCkge1xuICBjb25zdCB7XG4gICAgZG9uZSxcbiAgICB2YWx1ZVxuICB9ID0gaW5wdXQubmV4dCgpO1xuICByZXR1cm4gZG9uZSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgc2luZ2xlIHZhbGlkYXRpb24gcmVzdWx0IHRvIGEgZmFpbHVyZS5cbiAqL1xuXG5mdW5jdGlvbiB0b0ZhaWx1cmUocmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKSB7XG4gIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgIHJlc3VsdCA9IHt9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0ge1xuICAgICAgbWVzc2FnZTogcmVzdWx0XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBwYXRoLFxuICAgIGJyYW5jaFxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIHR5cGVcbiAgfSA9IHN0cnVjdDtcbiAgY29uc3Qge1xuICAgIHJlZmluZW1lbnQsXG4gICAgbWVzc2FnZSA9IFwiRXhwZWN0ZWQgYSB2YWx1ZSBvZiB0eXBlIGBcIiArIHR5cGUgKyBcImBcIiArIChyZWZpbmVtZW50ID8gXCIgd2l0aCByZWZpbmVtZW50IGBcIiArIHJlZmluZW1lbnQgKyBcImBcIiA6ICcnKSArIFwiLCBidXQgcmVjZWl2ZWQ6IGBcIiArIHByaW50KHZhbHVlKSArIFwiYFwiXG4gIH0gPSByZXN1bHQ7XG4gIHJldHVybiB7XG4gICAgdmFsdWUsXG4gICAgdHlwZSxcbiAgICByZWZpbmVtZW50LFxuICAgIGtleTogcGF0aFtwYXRoLmxlbmd0aCAtIDFdLFxuICAgIHBhdGgsXG4gICAgYnJhbmNoLFxuICAgIC4uLnJlc3VsdCxcbiAgICBtZXNzYWdlXG4gIH07XG59XG4vKipcbiAqIENvbnZlcnQgYSB2YWxpZGF0aW9uIHJlc3VsdCB0byBhbiBpdGVyYWJsZSBvZiBmYWlsdXJlcy5cbiAqL1xuXG5mdW5jdGlvbiogdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgaWYgKCFpc0l0ZXJhYmxlKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBbcmVzdWx0XTtcbiAgfVxuXG4gIGZvciAoY29uc3QgciBvZiByZXN1bHQpIHtcbiAgICBjb25zdCBmYWlsdXJlID0gdG9GYWlsdXJlKHIsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpO1xuXG4gICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgIHlpZWxkIGZhaWx1cmU7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIENoZWNrIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgdHJhdmVyc2luZyBkZWVwbHkgaW50byBuZXN0ZWQgdmFsdWVzLCBhbmRcbiAqIHJldHVybmluZyBhbiBpdGVyYXRvciBvZiBmYWlsdXJlcyBvciBzdWNjZXNzLlxuICovXG5cbmZ1bmN0aW9uKiBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHBhdGggPSBbXSxcbiAgICBicmFuY2ggPSBbdmFsdWVdLFxuICAgIGNvZXJjZSA9IGZhbHNlLFxuICAgIG1hc2sgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY3R4ID0ge1xuICAgIHBhdGgsXG4gICAgYnJhbmNoXG4gIH07XG5cbiAgaWYgKGNvZXJjZSkge1xuICAgIHZhbHVlID0gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG5cbiAgICBpZiAobWFzayAmJiBzdHJ1Y3QudHlwZSAhPT0gJ3R5cGUnICYmIGlzT2JqZWN0KHN0cnVjdC5zY2hlbWEpICYmIGlzT2JqZWN0KHZhbHVlKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChzdHJ1Y3Quc2NoZW1hW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHZhbGlkID0gdHJ1ZTtcblxuICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSkge1xuICAgIHZhbGlkID0gZmFsc2U7XG4gICAgeWllbGQgW2ZhaWx1cmUsIHVuZGVmaW5lZF07XG4gIH1cblxuICBmb3IgKGxldCBbaywgdiwgc10gb2Ygc3RydWN0LmVudHJpZXModmFsdWUsIGN0eCkpIHtcbiAgICBjb25zdCB0cyA9IHJ1bih2LCBzLCB7XG4gICAgICBwYXRoOiBrID09PSB1bmRlZmluZWQgPyBwYXRoIDogWy4uLnBhdGgsIGtdLFxuICAgICAgYnJhbmNoOiBrID09PSB1bmRlZmluZWQgPyBicmFuY2ggOiBbLi4uYnJhbmNoLCB2XSxcbiAgICAgIGNvZXJjZSxcbiAgICAgIG1hc2tcbiAgICB9KTtcblxuICAgIGZvciAoY29uc3QgdCBvZiB0cykge1xuICAgICAgaWYgKHRbMF0pIHtcbiAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgeWllbGQgW3RbMF0sIHVuZGVmaW5lZF07XG4gICAgICB9IGVsc2UgaWYgKGNvZXJjZSkge1xuICAgICAgICB2ID0gdFsxXTtcblxuICAgICAgICBpZiAoayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFsdWUgPSB2O1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgdmFsdWUuc2V0KGssIHYpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgdmFsdWUuYWRkKHYpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh2YWxpZCkge1xuICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSkge1xuICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICAgIH1cbiAgfVxuXG4gIGlmICh2YWxpZCkge1xuICAgIHlpZWxkIFt1bmRlZmluZWQsIHZhbHVlXTtcbiAgfVxufVxuXG4vKipcbiAqIGBTdHJ1Y3RgIG9iamVjdHMgZW5jYXBzdWxhdGUgdGhlIHZhbGlkYXRpb24gbG9naWMgZm9yIGEgc3BlY2lmaWMgdHlwZSBvZlxuICogdmFsdWVzLiBPbmNlIGNvbnN0cnVjdGVkLCB5b3UgdXNlIHRoZSBgYXNzZXJ0YCwgYGlzYCBvciBgdmFsaWRhdGVgIGhlbHBlcnMgdG9cbiAqIHZhbGlkYXRlIHVua25vd24gaW5wdXQgZGF0YSBhZ2FpbnN0IHRoZSBzdHJ1Y3QuXG4gKi9cblxuY2xhc3MgU3RydWN0IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICB0aGlzLlRZUEUgPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlID0gdm9pZCAwO1xuICAgIHRoaXMuc2NoZW1hID0gdm9pZCAwO1xuICAgIHRoaXMuY29lcmNlciA9IHZvaWQgMDtcbiAgICB0aGlzLnZhbGlkYXRvciA9IHZvaWQgMDtcbiAgICB0aGlzLnJlZmluZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5lbnRyaWVzID0gdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBzY2hlbWEsXG4gICAgICB2YWxpZGF0b3IsXG4gICAgICByZWZpbmVyLFxuICAgICAgY29lcmNlciA9IHZhbHVlID0+IHZhbHVlLFxuICAgICAgZW50cmllcyA9IGZ1bmN0aW9uKiAoKSB7fVxuICAgIH0gPSBwcm9wcztcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgdGhpcy5jb2VyY2VyID0gY29lcmNlcjtcblxuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIHRoaXMudmFsaWRhdG9yID0gKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvcih2YWx1ZSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgdGhpcywgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWxpZGF0b3IgPSAoKSA9PiBbXTtcbiAgICB9XG5cbiAgICBpZiAocmVmaW5lcikge1xuICAgICAgdGhpcy5yZWZpbmVyID0gKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmluZXIodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVmaW5lciA9ICgpID0+IFtdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBwYXNzZXMgdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24sIHRocm93aW5nIGlmIGl0IGRvZXNuJ3QuXG4gICAqL1xuXG5cbiAgYXNzZXJ0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGFzc2VydCh2YWx1ZSwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIGNvZXJjaW9uIGxvZ2ljLCB0aGVuIHZhbGlkYXRlIGl0LlxuICAgKi9cblxuXG4gIGNyZWF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGUodmFsdWUsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbi5cbiAgICovXG5cblxuICBpcyh2YWx1ZSkge1xuICAgIHJldHVybiBpcyh2YWx1ZSwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIE1hc2sgYSB2YWx1ZSwgY29lcmNpbmcgYW5kIHZhbGlkYXRpbmcgaXQsIGJ1dCByZXR1cm5pbmcgb25seSB0aGUgc3Vic2V0IG9mXG4gICAqIHByb3BlcnRpZXMgZGVmaW5lZCBieSB0aGUgc3RydWN0J3Mgc2NoZW1hLlxuICAgKi9cblxuXG4gIG1hc2sodmFsdWUpIHtcbiAgICByZXR1cm4gbWFzayh2YWx1ZSwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGEgdmFsdWUgd2l0aCB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiBsb2dpYywgcmV0dXJuaW5nIGEgdHVwbGVcbiAgICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIFlvdSBtYXkgb3B0aW9uYWxseSBwYXNzIGB0cnVlYCBmb3IgdGhlIGB3aXRoQ29lcmNpb25gIGFyZ3VtZW50IHRvIGNvZXJjZVxuICAgKiB0aGUgdmFsdWUgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdmFsaWRhdGUgaXQuIElmIHlvdSBkbywgdGhlIHJlc3VsdCB3aWxsXG4gICAqIGNvbnRhaW4gdGhlIGNvZXJjZWQgcmVzdWx0IHdoZW4gc3VjY2Vzc2Z1bC5cbiAgICovXG5cblxuICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdGUodmFsdWUsIHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbn1cbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QsIHRocm93aW5nIGlmIGl0IGRvZXNuJ3QuXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBzdHJ1Y3QpIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCk7XG5cbiAgaWYgKHJlc3VsdFswXSkge1xuICAgIHRocm93IHJlc3VsdFswXTtcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSB2YWx1ZSB3aXRoIHRoZSBjb2VyY2lvbiBsb2dpYyBvZiBzdHJ1Y3QgYW5kIHZhbGlkYXRlIGl0LlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSwgc3RydWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHtcbiAgICBjb2VyY2U6IHRydWVcbiAgfSk7XG5cbiAgaWYgKHJlc3VsdFswXSkge1xuICAgIHRocm93IHJlc3VsdFswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzdWx0WzFdO1xuICB9XG59XG4vKipcbiAqIE1hc2sgYSB2YWx1ZSwgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgYSBzdHJ1Y3QuXG4gKi9cblxuZnVuY3Rpb24gbWFzayh2YWx1ZSwgc3RydWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHtcbiAgICBjb2VyY2U6IHRydWUsXG4gICAgbWFzazogdHJ1ZVxuICB9KTtcblxuICBpZiAocmVzdWx0WzBdKSB7XG4gICAgdGhyb3cgcmVzdWx0WzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXN1bHRbMV07XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QuXG4gKi9cblxuZnVuY3Rpb24gaXModmFsdWUsIHN0cnVjdCkge1xuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0KTtcbiAgcmV0dXJuICFyZXN1bHRbMF07XG59XG4vKipcbiAqIFZhbGlkYXRlIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgcmV0dXJuaW5nIGFuIGVycm9yIGlmIGludmFsaWQsIG9yIHRoZVxuICogdmFsdWUgKHdpdGggcG90ZW50aWFsIGNvZXJjaW9uKSBpZiB2YWxpZC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBjb25zdCB0dXBsZXMgPSBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucyk7XG4gIGNvbnN0IHR1cGxlID0gc2hpZnRJdGVyYXRvcih0dXBsZXMpO1xuXG4gIGlmICh0dXBsZVswXSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFN0cnVjdEVycm9yKHR1cGxlWzBdLCBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIChjb25zdCB0IG9mIHR1cGxlcykge1xuICAgICAgICBpZiAodFswXSkge1xuICAgICAgICAgIHlpZWxkIHRbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gW2Vycm9yLCB1bmRlZmluZWRdO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHYgPSB0dXBsZVsxXTtcbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgdl07XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgU3RydWN0cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBTdHJ1Y3RzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgY29uc3QgaXNUeXBlID0gU3RydWN0c1swXS50eXBlID09PSAndHlwZSc7XG4gIGNvbnN0IHNjaGVtYXMgPSBTdHJ1Y3RzLm1hcChzID0+IHMuc2NoZW1hKTtcbiAgY29uc3Qgc2NoZW1hID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uc2NoZW1hcyk7XG4gIHJldHVybiBpc1R5cGUgPyB0eXBlKHNjaGVtYSkgOiBvYmplY3Qoc2NoZW1hKTtcbn1cbi8qKlxuICogRGVmaW5lIGEgbmV3IHN0cnVjdCB0eXBlIHdpdGggYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmUobmFtZSwgdmFsaWRhdG9yKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiBuYW1lLFxuICAgIHNjaGVtYTogbnVsbCxcbiAgICB2YWxpZGF0b3JcbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgc3RydWN0LCBidXQgdGhlIHZhbHVlIGlzIGFsbG93ZWQgdG9cbiAqIGJlIGB1bmRlZmluZWRgLiBgbG9nYCB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgdmFsdWUgaXMgbm90IGB1bmRlZmluZWRgLlxuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoc3RydWN0LCBsb2cpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyAuLi5zdHJ1Y3QsXG4gICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG5cbiAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2codmFsdWUsIGN0eCk7XG4gICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc3RydWN0IHdpdGggZHluYW1pYyB2YWxpZGF0aW9uIGxvZ2ljLlxuICpcbiAqIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgdGhlIHZhbHVlIGN1cnJlbnRseSBiZWluZyB2YWxpZGF0ZWQsIGFuZCBtdXN0XG4gKiByZXR1cm4gYSBzdHJ1Y3Qgb2JqZWN0IHRvIHZhbGlkYXRlIGl0IHdpdGguIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBtb2RlbFxuICogdmFsaWRhdGlvbiBsb2dpYyB0aGF0IGNoYW5nZXMgYmFzZWQgb24gaXRzIGlucHV0LlxuICovXG5cbmZ1bmN0aW9uIGR5bmFtaWMoZm4pIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdkeW5hbWljJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgfSxcblxuICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgfSxcblxuICAgIHJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICByZXR1cm4gc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBsYXppbHkgZXZhbHVhdGVkIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdmFsaWRhdGlvbiBpcyBydW4gd2l0aCB0aGUgc3RydWN0LCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAqIGFuZCBtdXN0IHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdXNlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgY2FzZXMgd2hlcmUgeW91XG4gKiB3YW50IHRvIGhhdmUgc2VsZi1yZWZlcmVudGlhbCBzdHJ1Y3RzIGZvciBuZXN0ZWQgZGF0YSBzdHJ1Y3R1cmVzIHRvIGF2b2lkIGFcbiAqIGNpcmN1bGFyIGRlZmluaXRpb24gcHJvYmxlbS5cbiAqL1xuXG5mdW5jdGlvbiBsYXp5KGZuKSB7XG4gIGxldCBzdHJ1Y3Q7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnbGF6eScsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgdmFyIF9zdHJ1Y3Q7XG5cbiAgICAgIChfc3RydWN0ID0gc3RydWN0KSAhPSBudWxsID8gX3N0cnVjdCA6IHN0cnVjdCA9IGZuKCk7XG4gICAgICB5aWVsZCogc3RydWN0LmVudHJpZXModmFsdWUsIGN0eCk7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICB2YXIgX3N0cnVjdDI7XG5cbiAgICAgIChfc3RydWN0MiA9IHN0cnVjdCkgIT0gbnVsbCA/IF9zdHJ1Y3QyIDogc3RydWN0ID0gZm4oKTtcbiAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgIHZhciBfc3RydWN0MztcblxuICAgICAgKF9zdHJ1Y3QzID0gc3RydWN0KSAhPSBudWxsID8gX3N0cnVjdDMgOiBzdHJ1Y3QgPSBmbigpO1xuICAgICAgcmV0dXJuIHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgIH0sXG5cbiAgICByZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgIHZhciBfc3RydWN0NDtcblxuICAgICAgKF9zdHJ1Y3Q0ID0gc3RydWN0KSAhPSBudWxsID8gX3N0cnVjdDQgOiBzdHJ1Y3QgPSBmbigpO1xuICAgICAgcmV0dXJuIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgZXhjbHVkaW5nXG4gKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBPbWl0YCB1dGlsaXR5LlxuICovXG5cbmZ1bmN0aW9uIG9taXQoc3RydWN0LCBrZXlzKSB7XG4gIGNvbnN0IHtcbiAgICBzY2hlbWFcbiAgfSA9IHN0cnVjdDtcbiAgY29uc3Qgc3Vic2NoZW1hID0geyAuLi5zY2hlbWFcbiAgfTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgZGVsZXRlIHN1YnNjaGVtYVtrZXldO1xuICB9XG5cbiAgc3dpdGNoIChzdHJ1Y3QudHlwZSkge1xuICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgcmV0dXJuIHR5cGUoc3Vic2NoZW1hKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSk7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgd2l0aCBhbGwgb2YgaXRzXG4gKiBwcm9wZXJ0aWVzIGFsbG93ZWQgdG8gYmUgYHVuZGVmaW5lZGAuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFBhcnRpYWxgIHV0aWxpdHkuXG4gKi9cblxuZnVuY3Rpb24gcGFydGlhbChzdHJ1Y3QpIHtcbiAgY29uc3Qgc2NoZW1hID0gc3RydWN0IGluc3RhbmNlb2YgU3RydWN0ID8geyAuLi5zdHJ1Y3Quc2NoZW1hXG4gIH0gOiB7IC4uLnN0cnVjdFxuICB9O1xuXG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgIHNjaGVtYVtrZXldID0gb3B0aW9uYWwoc2NoZW1hW2tleV0pO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdChzY2hlbWEpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCBvbmx5IGluY2x1ZGluZ1xuICogc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUGlja2AgdXRpbGl0eS5cbiAqL1xuXG5mdW5jdGlvbiBwaWNrKHN0cnVjdCwga2V5cykge1xuICBjb25zdCB7XG4gICAgc2NoZW1hXG4gIH0gPSBzdHJ1Y3Q7XG4gIGNvbnN0IHN1YnNjaGVtYSA9IHt9O1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBzdWJzY2hlbWFba2V5XSA9IHNjaGVtYVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdChzdWJzY2hlbWEpO1xufVxuLyoqXG4gKiBEZWZpbmUgYSBuZXcgc3RydWN0IHR5cGUgd2l0aCBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuICpcbiAqIEBkZXByZWNhdGVkIFRoaXMgZnVuY3Rpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBgZGVmaW5lYC5cbiAqL1xuXG5mdW5jdGlvbiBzdHJ1Y3QobmFtZSwgdmFsaWRhdG9yKSB7XG4gIGNvbnNvbGUud2Fybignc3VwZXJzdHJ1Y3RAMC4xMSAtIFRoZSBgc3RydWN0YCBoZWxwZXIgaGFzIGJlZW4gcmVuYW1lZCB0byBgZGVmaW5lYC4nKTtcbiAgcmV0dXJuIGRlZmluZShuYW1lLCB2YWxpZGF0b3IpO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBhbnkoKSB7XG4gIHJldHVybiBkZWZpbmUoJ2FueScsICgpID0+IHRydWUpO1xufVxuZnVuY3Rpb24gYXJyYXkoRWxlbWVudCkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2FycmF5JyxcbiAgICBzY2hlbWE6IEVsZW1lbnQsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKEVsZW1lbnQgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBbaSwgdl0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgeWllbGQgW2ksIHYsIEVsZW1lbnRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNsaWNlKCkgOiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhbiBhcnJheSB2YWx1ZSwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBiaWdpbnQuXG4gKi9cblxuZnVuY3Rpb24gYmlnaW50KCkge1xuICByZXR1cm4gZGVmaW5lKCdiaWdpbnQnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCc7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAqL1xuXG5mdW5jdGlvbiBib29sZWFuKCkge1xuICByZXR1cm4gZGVmaW5lKCdib29sZWFuJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBgRGF0ZWAuXG4gKlxuICogTm90ZTogdGhpcyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgdmFsdWUgaXMgKm5vdCogYW4gaW52YWxpZCBgRGF0ZWAgb2JqZWN0LFxuICogd2hpY2ggY2FuIG9jY3VyIHdoZW4gcGFyc2luZyBhIGRhdGUgZmFpbHMgYnV0IHN0aWxsIHJldHVybnMgYSBgRGF0ZWAuXG4gKi9cblxuZnVuY3Rpb24gZGF0ZSgpIHtcbiAgcmV0dXJuIGRlZmluZSgnZGF0ZScsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpIHx8IFwiRXhwZWN0ZWQgYSB2YWxpZCBgRGF0ZWAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGVudW1zKHZhbHVlcykge1xuICBjb25zdCBzY2hlbWEgPSB7fTtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSB2YWx1ZXMubWFwKHYgPT4gcHJpbnQodikpLmpvaW4oKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiB2YWx1ZXMpIHtcbiAgICBzY2hlbWFba2V5XSA9IGtleTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnZW51bXMnLFxuICAgIHNjaGVtYSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkgfHwgXCJFeHBlY3RlZCBvbmUgb2YgYFwiICsgZGVzY3JpcHRpb24gKyBcImAsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gZnVuYygpIHtcbiAgcmV0dXJuIGRlZmluZSgnZnVuYycsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8IFwiRXhwZWN0ZWQgYSBmdW5jdGlvbiwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgYSBzcGVjaWZpYyBjbGFzcy5cbiAqL1xuXG5mdW5jdGlvbiBpbnN0YW5jZShDbGFzcykge1xuICByZXR1cm4gZGVmaW5lKCdpbnN0YW5jZScsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBDbGFzcyB8fCBcIkV4cGVjdGVkIGEgYFwiICsgQ2xhc3MubmFtZSArIFwiYCBpbnN0YW5jZSwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqL1xuXG5mdW5jdGlvbiBpbnRlZ2VyKCkge1xuICByZXR1cm4gZGVmaW5lKCdpbnRlZ2VyJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhbiBpbnRlZ2VyLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBtYXRjaGVzIGFsbCBvZiBhIHNldCBvZiB0eXBlcy5cbiAqL1xuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oU3RydWN0cykge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2ludGVyc2VjdGlvbicsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgeWllbGQqIFMuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgKnZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICB5aWVsZCogUy52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgICpyZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgIHlpZWxkKiBTLnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xufVxuZnVuY3Rpb24gbGl0ZXJhbChjb25zdGFudCkge1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IHByaW50KGNvbnN0YW50KTtcbiAgY29uc3QgdCA9IHR5cGVvZiBjb25zdGFudDtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICBzY2hlbWE6IHQgPT09ICdzdHJpbmcnIHx8IHQgPT09ICdudW1iZXInIHx8IHQgPT09ICdib29sZWFuJyA/IGNvbnN0YW50IDogbnVsbCxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBjb25zdGFudCB8fCBcIkV4cGVjdGVkIHRoZSBsaXRlcmFsIGBcIiArIGRlc2NyaXB0aW9uICsgXCJgLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbmZ1bmN0aW9uIG1hcChLZXksIFZhbHVlKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnbWFwJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKEtleSAmJiBWYWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICB5aWVsZCBbaywgaywgS2V5XTtcbiAgICAgICAgICB5aWVsZCBbaywgdiwgVmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCA/IG5ldyBNYXAodmFsdWUpIDogdmFsdWU7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IFwiRXhwZWN0ZWQgYSBgTWFwYCBvYmplY3QsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBubyB2YWx1ZSBldmVyIHBhc3NlcyB2YWxpZGF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIG5ldmVyKCkge1xuICByZXR1cm4gZGVmaW5lKCduZXZlcicsICgpID0+IGZhbHNlKTtcbn1cbi8qKlxuICogQXVnbWVudCBhbiBleGlzdGluZyBzdHJ1Y3QgdG8gYWxsb3cgYG51bGxgIHZhbHVlcy5cbiAqL1xuXG5mdW5jdGlvbiBudWxsYWJsZShzdHJ1Y3QpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyAuLi5zdHJ1Y3QsXG4gICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IG51bGwgfHwgc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSxcbiAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IG51bGwgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eClcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBudW1iZXIuXG4gKi9cblxuZnVuY3Rpb24gbnVtYmVyKCkge1xuICByZXR1cm4gZGVmaW5lKCdudW1iZXInLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSB8fCBcIkV4cGVjdGVkIGEgbnVtYmVyLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG9iamVjdChzY2hlbWEpIHtcbiAgY29uc3Qga25vd25zID0gc2NoZW1hID8gT2JqZWN0LmtleXMoc2NoZW1hKSA6IFtdO1xuICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICBzY2hlbWE6IHNjaGVtYSA/IHNjaGVtYSA6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKHNjaGVtYSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgdW5rbm93bnMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHZhbHVlKSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga25vd25zKSB7XG4gICAgICAgICAgdW5rbm93bnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgc2NoZW1hW2tleV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdW5rbm93bnMpIHtcbiAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZVtrZXldLCBOZXZlcl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8geyAuLi52YWx1ZVxuICAgICAgfSA6IHZhbHVlO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byBhbGxvdyBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gb3B0aW9uYWwoc3RydWN0KSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHsgLi4uc3RydWN0LFxuICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSxcbiAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KVxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBrZXlzIGFuZCB2YWx1ZXMgb2Ygc3BlY2lmaWMgdHlwZXMsIGJ1dFxuICogd2l0aG91dCBlbnN1cmluZyBhbnkgc3BlY2lmaWMgc2hhcGUgb2YgcHJvcGVydGllcy5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUmVjb3JkYCB1dGlsaXR5LlxuICovXG5cbmZ1bmN0aW9uIHJlY29yZChLZXksIFZhbHVlKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAncmVjb3JkJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICBjb25zdCB2ID0gdmFsdWVba107XG4gICAgICAgICAgeWllbGQgW2ssIGssIEtleV07XG4gICAgICAgICAgeWllbGQgW2ssIHYsIFZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYFJlZ0V4cGAuXG4gKlxuICogTm90ZTogdGhpcyBkb2VzIG5vdCB0ZXN0IHRoZSB2YWx1ZSBhZ2FpbnN0IHRoZSByZWd1bGFyIGV4cHJlc3Npb24hIEZvciB0aGF0XG4gKiB5b3UgbmVlZCB0byB1c2UgdGhlIGBwYXR0ZXJuKClgIHJlZmluZW1lbnQuXG4gKi9cblxuZnVuY3Rpb24gcmVnZXhwKCkge1xuICByZXR1cm4gZGVmaW5lKCdyZWdleHAnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNldChFbGVtZW50KSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnc2V0JyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKEVsZW1lbnQgJiYgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgeWllbGQgW3YsIHYsIEVsZW1lbnRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNldCA/IG5ldyBTZXQodmFsdWUpIDogdmFsdWU7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0IHx8IFwiRXhwZWN0ZWQgYSBgU2V0YCBvYmplY3QsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgc3RyaW5nLlxuICovXG5cbmZ1bmN0aW9uIHN0cmluZygpIHtcbiAgcmV0dXJuIGRlZmluZSgnc3RyaW5nJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IFwiRXhwZWN0ZWQgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdHVwbGUgb2YgYSBzcGVjaWZpYyBsZW5ndGgsIGFuZCB0aGF0IGVhY2ggb2YgaXRzXG4gKiBlbGVtZW50cyBpcyBvZiBhIHNwZWNpZmljIHR5cGUuXG4gKi9cblxuZnVuY3Rpb24gdHVwbGUoU3RydWN0cykge1xuICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAndHVwbGUnLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoU3RydWN0cy5sZW5ndGgsIHZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHlpZWxkIFtpLCB2YWx1ZVtpXSwgU3RydWN0c1tpXSB8fCBOZXZlcl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhbiBhcnJheSwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaGFzIGEgc2V0IG9mIGtub3duIHByb3BlcnRpZXMgb2Ygc3BlY2lmaWMgdHlwZXMuXG4gKlxuICogTm90ZTogVW5yZWNvZ25pemVkIHByb3BlcnRpZXMgYXJlIGFsbG93ZWQgYW5kIHVudG91Y2hlZC4gVGhpcyBpcyBzaW1pbGFyIHRvXG4gKiBob3cgVHlwZVNjcmlwdCdzIHN0cnVjdHVyYWwgdHlwaW5nIHdvcmtzLlxuICovXG5cbmZ1bmN0aW9uIHR5cGUoc2NoZW1hKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEpO1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3R5cGUnLFxuICAgIHNjaGVtYSxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICAgICAgeWllbGQgW2ssIHZhbHVlW2tdLCBzY2hlbWFba11dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSB8fCBcIkV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgYSBzZXQgb2YgdHlwZXMuXG4gKi9cblxuZnVuY3Rpb24gdW5pb24oU3RydWN0cykge1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IFN0cnVjdHMubWFwKHMgPT4gcy50eXBlKS5qb2luKCcgfCAnKTtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICd1bmlvbicsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICBjb25zdCBmaXJzdE1hdGNoID0gU3RydWN0cy5maW5kKHMgPT4ge1xuICAgICAgICBjb25zdCBbZV0gPSBzLnZhbGlkYXRlKHZhbHVlLCB7XG4gICAgICAgICAgY29lcmNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gIWU7XG4gICAgICB9KSB8fCB1bmtub3duKCk7XG4gICAgICByZXR1cm4gZmlyc3RNYXRjaC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3QgZmFpbHVyZXMgPSBbXTtcblxuICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgY29uc3QgWy4uLnR1cGxlc10gPSBydW4odmFsdWUsIFMsIGN0eCk7XG4gICAgICAgIGNvbnN0IFtmaXJzdF0gPSB0dXBsZXM7XG5cbiAgICAgICAgaWYgKCFmaXJzdFswXSkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtmYWlsdXJlXSBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmVzLnB1c2goZmFpbHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXCJFeHBlY3RlZCB0aGUgdmFsdWUgdG8gc2F0aXNmeSBhIHVuaW9uIG9mIGBcIiArIGRlc2NyaXB0aW9uICsgXCJgLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpLCAuLi5mYWlsdXJlc107XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhbnkgdmFsdWUgcGFzc2VzIHZhbGlkYXRpb24sIHdpdGhvdXQgd2lkZW5pbmcgaXRzIHR5cGUgdG8gYGFueWAuXG4gKi9cblxuZnVuY3Rpb24gdW5rbm93bigpIHtcbiAgcmV0dXJuIGRlZmluZSgndW5rbm93bicsICgpID0+IHRydWUpO1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYSBgU3RydWN0YCB0byBhZGQgYW4gYWRkaXRpb25hbCBjb2VyY2lvbiBzdGVwIHRvIGl0cyBpbnB1dC5cbiAqXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJhbnNmb3JtIGlucHV0IGRhdGEgYmVmb3JlIHZhbGlkYXRpbmcgaXQsIHRvIGluY3JlYXNlIHRoZVxuICogbGlrZWxpaG9vZCB0aGF0IGl0IHBhc3NlcyB2YWxpZGF0aW9u4oCUZm9yIGV4YW1wbGUgZm9yIGRlZmF1bHQgdmFsdWVzLCBwYXJzaW5nXG4gKiBkaWZmZXJlbnQgZm9ybWF0cywgZXRjLlxuICpcbiAqIE5vdGU6IFlvdSBtdXN0IHVzZSBgY3JlYXRlKHZhbHVlLCBTdHJ1Y3QpYCBvbiB0aGUgdmFsdWUgdG8gaGF2ZSB0aGUgY29lcmNpb25cbiAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZShzdHJ1Y3QsIGNvbmRpdGlvbiwgY29lcmNlcikge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7IC4uLnN0cnVjdCxcbiAgICBjb2VyY2VyOiAodmFsdWUsIGN0eCkgPT4ge1xuICAgICAgcmV0dXJuIGlzKHZhbHVlLCBjb25kaXRpb24pID8gc3RydWN0LmNvZXJjZXIoY29lcmNlcih2YWx1ZSwgY3R4KSwgY3R4KSA6IHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gcmVwbGFjZSBgdW5kZWZpbmVkYCB2YWx1ZXMgd2l0aCBhIGRlZmF1bHQuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cblxuZnVuY3Rpb24gZGVmYXVsdGVkKHN0cnVjdCwgZmFsbGJhY2ssIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBjb2VyY2Uoc3RydWN0LCB1bmtub3duKCksIHggPT4ge1xuICAgIGNvbnN0IGYgPSB0eXBlb2YgZmFsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBmYWxsYmFjaygpIDogZmFsbGJhY2s7XG5cbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZjtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuc3RyaWN0ICYmIGlzUGxhaW5PYmplY3QoeCkgJiYgaXNQbGFpbk9iamVjdChmKSkge1xuICAgICAgY29uc3QgcmV0ID0geyAuLi54XG4gICAgICB9O1xuICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gZikge1xuICAgICAgICBpZiAocmV0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldFtrZXldID0gZltrZXldO1xuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHg7XG4gIH0pO1xufVxuLyoqXG4gKiBBdWdtZW50IGEgc3RydWN0IHRvIHRyaW0gc3RyaW5nIGlucHV0cy5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqL1xuXG5mdW5jdGlvbiB0cmltbWVkKHN0cnVjdCkge1xuICByZXR1cm4gY29lcmNlKHN0cnVjdCwgc3RyaW5nKCksIHggPT4geC50cmltKCkpO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbWFwLCBvciBzZXQgaXMgZW1wdHkuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkoc3RydWN0KSB7XG4gIHJldHVybiByZWZpbmUoc3RydWN0LCAnZW1wdHknLCB2YWx1ZSA9PiB7XG4gICAgY29uc3Qgc2l6ZSA9IGdldFNpemUodmFsdWUpO1xuICAgIHJldHVybiBzaXplID09PSAwIHx8IFwiRXhwZWN0ZWQgYW4gZW1wdHkgXCIgKyBzdHJ1Y3QudHlwZSArIFwiIGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgYFwiICsgc2l6ZSArIFwiYFwiO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICByZXR1cm4gdmFsdWUuc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgbnVtYmVyIG9yIGRhdGUgaXMgYmVsb3cgYSB0aHJlc2hvbGQuXG4gKi9cblxuXG5mdW5jdGlvbiBtYXgoc3RydWN0LCB0aHJlc2hvbGQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBleGNsdXNpdmVcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiByZWZpbmUoc3RydWN0LCAnbWF4JywgdmFsdWUgPT4ge1xuICAgIHJldHVybiBleGNsdXNpdmUgPyB2YWx1ZSA8IHRocmVzaG9sZCA6IHZhbHVlIDw9IHRocmVzaG9sZCB8fCBcIkV4cGVjdGVkIGEgXCIgKyBzdHJ1Y3QudHlwZSArIFwiIGxlc3MgdGhhbiBcIiArIChleGNsdXNpdmUgPyAnJyA6ICdvciBlcXVhbCB0byAnKSArIHRocmVzaG9sZCArIFwiIGJ1dCByZWNlaXZlZCBgXCIgKyB2YWx1ZSArIFwiYFwiO1xuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBhYm92ZSBhIHRocmVzaG9sZC5cbiAqL1xuXG5mdW5jdGlvbiBtaW4oc3RydWN0LCB0aHJlc2hvbGQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBleGNsdXNpdmVcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiByZWZpbmUoc3RydWN0LCAnbWluJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiBleGNsdXNpdmUgPyB2YWx1ZSA+IHRocmVzaG9sZCA6IHZhbHVlID49IHRocmVzaG9sZCB8fCBcIkV4cGVjdGVkIGEgXCIgKyBzdHJ1Y3QudHlwZSArIFwiIGdyZWF0ZXIgdGhhbiBcIiArIChleGNsdXNpdmUgPyAnJyA6ICdvciBlcXVhbCB0byAnKSArIHRocmVzaG9sZCArIFwiIGJ1dCByZWNlaXZlZCBgXCIgKyB2YWx1ZSArIFwiYFwiO1xuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcsIGFycmF5LCBtYXAgb3Igc2V0IGlzIG5vdCBlbXB0eS5cbiAqL1xuXG5mdW5jdGlvbiBub25lbXB0eShzdHJ1Y3QpIHtcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdub25lbXB0eScsIHZhbHVlID0+IHtcbiAgICBjb25zdCBzaXplID0gZ2V0U2l6ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHNpemUgPiAwIHx8IFwiRXhwZWN0ZWQgYSBub25lbXB0eSBcIiArIHN0cnVjdC50eXBlICsgXCIgYnV0IHJlY2VpdmVkIGFuIGVtcHR5IG9uZVwiO1xuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcgbWF0Y2hlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqL1xuXG5mdW5jdGlvbiBwYXR0ZXJuKHN0cnVjdCwgcmVnZXhwKSB7XG4gIHJldHVybiByZWZpbmUoc3RydWN0LCAncGF0dGVybicsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gcmVnZXhwLnRlc3QodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYSBcIiArIHN0cnVjdC50eXBlICsgXCIgbWF0Y2hpbmcgYC9cIiArIHJlZ2V4cC5zb3VyY2UgKyBcIi9gIGJ1dCByZWNlaXZlZCBcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiO1xuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcsIGFycmF5LCBudW1iZXIsIGRhdGUsIG1hcCwgb3Igc2V0IGhhcyBhIHNpemUgKG9yIGxlbmd0aCwgb3IgdGltZSkgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAuXG4gKi9cblxuZnVuY3Rpb24gc2l6ZShzdHJ1Y3QsIG1pbiwgbWF4KSB7XG4gIGlmIChtYXggPT09IHZvaWQgMCkge1xuICAgIG1heCA9IG1pbjtcbiAgfVxuXG4gIGNvbnN0IGV4cGVjdGVkID0gXCJFeHBlY3RlZCBhIFwiICsgc3RydWN0LnR5cGU7XG4gIGNvbnN0IG9mID0gbWluID09PSBtYXggPyBcIm9mIGBcIiArIG1pbiArIFwiYFwiIDogXCJiZXR3ZWVuIGBcIiArIG1pbiArIFwiYCBhbmQgYFwiICsgbWF4ICsgXCJgXCI7XG4gIHJldHVybiByZWZpbmUoc3RydWN0LCAnc2l6ZScsIHZhbHVlID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiBtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4IHx8IGV4cGVjdGVkICsgXCIgXCIgKyBvZiArIFwiIGJ1dCByZWNlaXZlZCBgXCIgKyB2YWx1ZSArIFwiYFwiO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2l6ZVxuICAgICAgfSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIG1pbiA8PSBzaXplICYmIHNpemUgPD0gbWF4IHx8IGV4cGVjdGVkICsgXCIgd2l0aCBhIHNpemUgXCIgKyBvZiArIFwiIGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgYFwiICsgc2l6ZSArIFwiYFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxlbmd0aFxuICAgICAgfSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIG1pbiA8PSBsZW5ndGggJiYgbGVuZ3RoIDw9IG1heCB8fCBleHBlY3RlZCArIFwiIHdpdGggYSBsZW5ndGggXCIgKyBvZiArIFwiIGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIGxlbmd0aCBvZiBgXCIgKyBsZW5ndGggKyBcImBcIjtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBBdWdtZW50IGEgYFN0cnVjdGAgdG8gYWRkIGFuIGFkZGl0aW9uYWwgcmVmaW5lbWVudCB0byB0aGUgdmFsaWRhdGlvbi5cbiAqXG4gKiBUaGUgcmVmaW5lciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJlY2VpdmUgYSB2YWx1ZSBvZiB0aGUgc3RydWN0J3MgdHlwZSxcbiAqIGJlY2F1c2UgdGhlIHN0cnVjdCdzIGV4aXN0aW5nIHZhbGlkYXRpb24gd2lsbCBhbHJlYWR5IGhhdmUgcGFzc2VkLiBUaGlzXG4gKiBhbGxvd3MgeW91IHRvIGxheWVyIGFkZGl0aW9uYWwgdmFsaWRhdGlvbiBvbiB0b3Agb2YgZXhpc3Rpbmcgc3RydWN0cy5cbiAqL1xuXG5mdW5jdGlvbiByZWZpbmUoc3RydWN0LCBuYW1lLCByZWZpbmVyKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHsgLi4uc3RydWN0LFxuXG4gICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgeWllbGQqIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgIGNvbnN0IGZhaWx1cmVzID0gdG9GYWlsdXJlcyhyZXN1bHQsIGN0eCwgc3RydWN0LCB2YWx1ZSk7XG5cbiAgICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBmYWlsdXJlcykge1xuICAgICAgICB5aWVsZCB7IC4uLmZhaWx1cmUsXG4gICAgICAgICAgcmVmaW5lbWVudDogbmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcbn1cblxuZXhwb3J0IHsgU3RydWN0LCBTdHJ1Y3RFcnJvciwgYW55LCBhcnJheSwgYXNzZXJ0LCBhc3NpZ24sIGJpZ2ludCwgYm9vbGVhbiwgY29lcmNlLCBjcmVhdGUsIGRhdGUsIGRlZmF1bHRlZCwgZGVmaW5lLCBkZXByZWNhdGVkLCBkeW5hbWljLCBlbXB0eSwgZW51bXMsIGZ1bmMsIGluc3RhbmNlLCBpbnRlZ2VyLCBpbnRlcnNlY3Rpb24sIGlzLCBsYXp5LCBsaXRlcmFsLCBtYXAsIG1hc2ssIG1heCwgbWluLCBuZXZlciwgbm9uZW1wdHksIG51bGxhYmxlLCBudW1iZXIsIG9iamVjdCwgb21pdCwgb3B0aW9uYWwsIHBhcnRpYWwsIHBhdHRlcm4sIHBpY2ssIHJlY29yZCwgcmVmaW5lLCByZWdleHAsIHNldCwgc2l6ZSwgc3RyaW5nLCBzdHJ1Y3QsIHRyaW1tZWQsIHR1cGxlLCB0eXBlLCB1bmlvbiwgdW5rbm93biwgdmFsaWRhdGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlN0cnVjdEVycm9yIiwiVHlwZUVycm9yIiwiY29uc3RydWN0b3IiLCJmYWlsdXJlIiwiZmFpbHVyZXMiLCJjYWNoZWQiLCJtZXNzYWdlIiwicmVzdCIsInBhdGgiLCJtc2ciLCJsZW5ndGgiLCJqb2luIiwidmFsdWUiLCJrZXkiLCJ0eXBlIiwicmVmaW5lbWVudCIsImJyYW5jaCIsIk9iamVjdCIsImFzc2lnbiIsIm5hbWUiLCJfY2FjaGVkIiwiaXNJdGVyYWJsZSIsIngiLCJpc09iamVjdCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaXNQbGFpbk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImdldFByb3RvdHlwZU9mIiwicHJpbnQiLCJKU09OIiwic3RyaW5naWZ5Iiwic2hpZnRJdGVyYXRvciIsImlucHV0IiwiZG9uZSIsIm5leHQiLCJ1bmRlZmluZWQiLCJ0b0ZhaWx1cmUiLCJyZXN1bHQiLCJjb250ZXh0Iiwic3RydWN0IiwidG9GYWlsdXJlcyIsInIiLCJydW4iLCJvcHRpb25zIiwiY29lcmNlIiwibWFzayIsImN0eCIsImNvZXJjZXIiLCJzY2hlbWEiLCJBcnJheSIsImlzQXJyYXkiLCJ2YWxpZCIsInZhbGlkYXRvciIsImsiLCJ2IiwicyIsImVudHJpZXMiLCJ0cyIsInQiLCJNYXAiLCJzZXQiLCJTZXQiLCJhZGQiLCJyZWZpbmVyIiwiU3RydWN0IiwicHJvcHMiLCJUWVBFIiwiYXNzZXJ0IiwiY3JlYXRlIiwiaXMiLCJ2YWxpZGF0ZSIsInR1cGxlcyIsInR1cGxlIiwiZXJyb3IiLCJfbGVuIiwiYXJndW1lbnRzIiwiU3RydWN0cyIsIl9rZXkiLCJpc1R5cGUiLCJzY2hlbWFzIiwibWFwIiwib2JqZWN0IiwiZGVmaW5lIiwiZGVwcmVjYXRlZCIsImxvZyIsImR5bmFtaWMiLCJmbiIsImxhenkiLCJfc3RydWN0IiwiX3N0cnVjdDIiLCJfc3RydWN0MyIsIl9zdHJ1Y3Q0Iiwib21pdCIsImtleXMiLCJzdWJzY2hlbWEiLCJwYXJ0aWFsIiwib3B0aW9uYWwiLCJwaWNrIiwiY29uc29sZSIsIndhcm4iLCJhbnkiLCJhcnJheSIsIkVsZW1lbnQiLCJpIiwic2xpY2UiLCJiaWdpbnQiLCJib29sZWFuIiwiZGF0ZSIsIkRhdGUiLCJpc05hTiIsImdldFRpbWUiLCJlbnVtcyIsInZhbHVlcyIsImRlc2NyaXB0aW9uIiwiaW5jbHVkZXMiLCJmdW5jIiwiaW5zdGFuY2UiLCJDbGFzcyIsImludGVnZXIiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJpbnRlcnNlY3Rpb24iLCJTIiwibGl0ZXJhbCIsImNvbnN0YW50IiwiS2V5IiwiVmFsdWUiLCJuZXZlciIsIm51bGxhYmxlIiwibnVtYmVyIiwia25vd25zIiwiTmV2ZXIiLCJ1bmtub3ducyIsImRlbGV0ZSIsInJlY29yZCIsInJlZ2V4cCIsIlJlZ0V4cCIsInN0cmluZyIsIk1hdGgiLCJtYXgiLCJ1bmlvbiIsImZpcnN0TWF0Y2giLCJmaW5kIiwiZSIsInVua25vd24iLCJmaXJzdCIsInB1c2giLCJjb25kaXRpb24iLCJkZWZhdWx0ZWQiLCJmYWxsYmFjayIsImYiLCJzdHJpY3QiLCJyZXQiLCJjaGFuZ2VkIiwidHJpbW1lZCIsInRyaW0iLCJlbXB0eSIsInJlZmluZSIsInNpemUiLCJnZXRTaXplIiwidGhyZXNob2xkIiwiZXhjbHVzaXZlIiwibWluIiwibm9uZW1wdHkiLCJwYXR0ZXJuIiwidGVzdCIsInNvdXJjZSIsImV4cGVjdGVkIiwib2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/superstruct/lib/index.es.js\n");

/***/ })

};
;