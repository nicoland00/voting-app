"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodes = exports.createDependencies = void 0;
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const get_named_inputs_1 = require("@nx/devkit/src/utils/get-named-inputs");
const fs_1 = require("fs");
const cache_directory_1 = require("nx/src/utils/cache-directory");
const calculate_hash_for_create_nodes_1 = require("@nx/devkit/src/utils/calculate-hash-for-create-nodes");
const js_1 = require("@nx/js");
const config_utils_1 = require("@nx/devkit/src/utils/config-utils");
const cachePath = (0, path_1.join)(cache_directory_1.projectGraphCacheDirectory, 'next.hash');
const targetsCache = (0, fs_1.existsSync)(cachePath) ? readTargetsCache() : {};
const calculatedTargets = {};
function readTargetsCache() {
    return (0, devkit_1.readJsonFile)(cachePath);
}
function writeTargetsToCache(targets) {
    (0, devkit_1.writeJsonFile)(cachePath, targets);
}
const createDependencies = () => {
    writeTargetsToCache(calculatedTargets);
    return [];
};
exports.createDependencies = createDependencies;
exports.createNodes = [
    '**/next.config.{js,cjs,mjs}',
    async (configFilePath, options, context) => {
        const projectRoot = (0, path_1.dirname)(configFilePath);
        // Do not create a project if package.json and project.json isn't there.
        const siblingFiles = (0, fs_1.readdirSync)((0, path_1.join)(context.workspaceRoot, projectRoot));
        if (!siblingFiles.includes('package.json') &&
            !siblingFiles.includes('project.json')) {
            return {};
        }
        options = normalizeOptions(options);
        const hash = (0, calculate_hash_for_create_nodes_1.calculateHashForCreateNodes)(projectRoot, options, context, [
            (0, js_1.getLockFileName)((0, devkit_1.detectPackageManager)(context.workspaceRoot)),
        ]);
        const targets = targetsCache[hash] ??
            (await buildNextTargets(configFilePath, projectRoot, options, context));
        calculatedTargets[hash] = targets;
        return {
            projects: {
                [projectRoot]: {
                    root: projectRoot,
                    targets,
                },
            },
        };
    },
];
async function buildNextTargets(nextConfigPath, projectRoot, options, context) {
    const nextConfig = await getNextConfig(nextConfigPath, context);
    const namedInputs = (0, get_named_inputs_1.getNamedInputs)(projectRoot, context);
    const targets = {};
    targets[options.buildTargetName] = await getBuildTargetConfig(namedInputs, projectRoot, nextConfig);
    targets[options.devTargetName] = getDevTargetConfig(projectRoot);
    targets[options.startTargetName] = getStartTargetConfig(options, projectRoot);
    targets[options.serveStaticTargetName] = getStaticServeTargetConfig(options);
    return targets;
}
async function getBuildTargetConfig(namedInputs, projectRoot, nextConfig) {
    const nextOutputPath = await getOutputs(projectRoot, nextConfig);
    // Set output path here so that `withNx` can pick it up.
    const targetConfig = {
        command: `next build`,
        options: {
            cwd: projectRoot,
        },
        dependsOn: ['^build'],
        cache: true,
        inputs: getInputs(namedInputs),
        outputs: [nextOutputPath, `${nextOutputPath}/!(cache)`],
    };
    // TODO(ndcunningham): Update this to be consider different versions of next.js which is running
    // This doesn't actually need to be tty, but next.js has a bug, https://github.com/vercel/next.js/issues/62906, where it exits 0 when SIGINT is sent.
    targetConfig.options.tty = false;
    return targetConfig;
}
function getDevTargetConfig(projectRoot) {
    const targetConfig = {
        command: `next dev`,
        options: {
            cwd: projectRoot,
        },
    };
    return targetConfig;
}
function getStartTargetConfig(options, projectRoot) {
    const targetConfig = {
        command: `next start`,
        options: {
            cwd: projectRoot,
        },
        dependsOn: [options.buildTargetName],
    };
    return targetConfig;
}
function getStaticServeTargetConfig(options) {
    const targetConfig = {
        executor: '@nx/web:file-server',
        options: {
            buildTarget: options.buildTargetName,
            staticFilePath: '{projectRoot}/out',
            port: 3000,
            // Routes are found correctly with serve-static
            spa: false,
        },
    };
    return targetConfig;
}
async function getOutputs(projectRoot, nextConfig) {
    let dir = '.next';
    const { PHASE_PRODUCTION_BUILD } = require('next/constants');
    if (typeof nextConfig === 'function') {
        // Works for both async and sync functions.
        const configResult = await Promise.resolve(nextConfig(PHASE_PRODUCTION_BUILD, { defaultConfig: {} }));
        if (configResult?.distDir) {
            dir = configResult?.distDir;
        }
    }
    else if (typeof nextConfig === 'object' && nextConfig?.distDir) {
        // If nextConfig is an object, directly use its 'distDir' property.
        dir = nextConfig.distDir;
    }
    if (projectRoot === '.') {
        return `{projectRoot}/${dir}`;
    }
    else {
        return `{workspaceRoot}/${projectRoot}/${dir}`;
    }
}
function getNextConfig(configFilePath, context) {
    const resolvedPath = (0, path_1.join)(context.workspaceRoot, configFilePath);
    return (0, config_utils_1.loadConfigFile)(resolvedPath);
}
function normalizeOptions(options) {
    options ??= {};
    options.buildTargetName ??= 'build';
    options.devTargetName ??= 'dev';
    options.startTargetName ??= 'start';
    options.serveStaticTargetName ??= 'serve-static';
    return options;
}
function getInputs(namedInputs) {
    return [
        ...('production' in namedInputs
            ? ['default', '^production']
            : ['default', '^default']),
        {
            externalDependencies: ['next'],
        },
    ];
}
