"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodes = exports.createDependencies = void 0;
const cache_directory_1 = require("nx/src/utils/cache-directory");
const path_1 = require("path");
const fs_1 = require("fs");
const devkit_1 = require("@nx/devkit");
const calculate_hash_for_create_nodes_1 = require("@nx/devkit/src/utils/calculate-hash-for-create-nodes");
const js_1 = require("@nx/js");
const get_named_inputs_1 = require("@nx/devkit/src/utils/get-named-inputs");
// This import causes an error due to the module resolution used. If we switch to bundler or nodenext in the future we remove this ignore.
// @ts-ignore
const loadConfigFile_1 = require("rollup/loadConfigFile");
const cachePath = (0, path_1.join)(cache_directory_1.projectGraphCacheDirectory, 'rollup.hash');
const targetsCache = (0, fs_1.existsSync)(cachePath) ? readTargetsCache() : {};
const calculatedTargets = {};
function readTargetsCache() {
    return (0, devkit_1.readJsonFile)(cachePath);
}
function writeTargetsToCache(targets) {
    (0, devkit_1.writeJsonFile)(cachePath, targets);
}
const createDependencies = () => {
    writeTargetsToCache(calculatedTargets);
    return [];
};
exports.createDependencies = createDependencies;
exports.createNodes = [
    '**/rollup.config.{js,cjs,mjs}',
    async (configFilePath, options, context) => {
        const projectRoot = (0, path_1.dirname)(configFilePath);
        const fullyQualifiedProjectRoot = (0, path_1.join)(context.workspaceRoot, projectRoot);
        // Do not create a project if package.json and project.json do not exist
        const siblingFiles = (0, fs_1.readdirSync)(fullyQualifiedProjectRoot);
        if (!siblingFiles.includes('package.json') &&
            !siblingFiles.includes('project.json')) {
            return {};
        }
        options = normalizeOptions(options);
        const hash = (0, calculate_hash_for_create_nodes_1.calculateHashForCreateNodes)(projectRoot, options, context, [
            (0, js_1.getLockFileName)((0, devkit_1.detectPackageManager)(context.workspaceRoot)),
        ]);
        const targets = targetsCache[hash]
            ? targetsCache[hash]
            : await buildRollupTarget(configFilePath, projectRoot, options, context);
        calculatedTargets[hash] = targets;
        return {
            projects: {
                [projectRoot]: {
                    root: projectRoot,
                    targets,
                },
            },
        };
    },
];
async function buildRollupTarget(configFilePath, projectRoot, options, context) {
    const namedInputs = (0, get_named_inputs_1.getNamedInputs)(projectRoot, context);
    const rollupConfig = (await (0, loadConfigFile_1.loadConfigFile)((0, devkit_1.joinPathFragments)(context.workspaceRoot, configFilePath))).options;
    const outputs = getOutputs(rollupConfig, projectRoot);
    const targets = {};
    targets[options.buildTargetName] = {
        command: `rollup -c ${(0, path_1.basename)(configFilePath)}`,
        options: { cwd: projectRoot },
        cache: true,
        dependsOn: [`^${options.buildTargetName}`],
        inputs: [
            ...('production' in namedInputs
                ? ['production', '^production']
                : ['default', '^default']),
        ],
        outputs,
    };
    return targets;
}
function getOutputs(rollupConfigs, projectRoot) {
    const outputs = new Set();
    for (const rollupConfig of rollupConfigs) {
        if (rollupConfig.output) {
            const rollupConfigOutputs = [];
            if (Array.isArray(rollupConfig.output)) {
                rollupConfigOutputs.push(...rollupConfig.output);
            }
            else {
                rollupConfigOutputs.push(rollupConfig.output);
            }
            for (const output of rollupConfigOutputs) {
                const outputPathFromConfig = output.dir
                    ? output.dir
                    : output.file
                        ? (0, path_1.dirname)(output.file)
                        : 'dist';
                const outputPath = projectRoot === '.'
                    ? (0, devkit_1.joinPathFragments)(`{workspaceRoot}`, outputPathFromConfig)
                    : (0, devkit_1.joinPathFragments)(`{workspaceRoot}`, projectRoot, outputPathFromConfig);
                outputs.add(outputPath);
            }
        }
    }
    return Array.from(outputs);
}
function normalizeOptions(options) {
    options ??= {};
    options.buildTargetName ??= 'build';
    return options;
}
