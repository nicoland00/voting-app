"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.configurationGenerator = void 0;
const devkit_1 = require("@nx/devkit");
const get_import_path_1 = require("@nx/js/src/utils/get-import-path");
const init_1 = require("../init/init");
const add_build_target_defaults_1 = require("@nx/devkit/src/generators/add-build-target-defaults");
const ensure_dependencies_1 = require("../../utils/ensure-dependencies");
async function configurationGenerator(tree, options) {
    const tasks = [];
    tasks.push(await (0, init_1.rollupInitGenerator)(tree, { ...options, skipFormat: true }));
    if (!options.skipPackageJson) {
        tasks.push((0, ensure_dependencies_1.ensureDependencies)(tree, options));
    }
    options.buildTarget ??= 'build';
    checkForTargetConflicts(tree, options);
    addBuildTarget(tree, options);
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.configurationGenerator = configurationGenerator;
function checkForTargetConflicts(tree, options) {
    if (options.skipValidation)
        return;
    const project = (0, devkit_1.readProjectConfiguration)(tree, options.project);
    if (project.targets?.[options.buildTarget]) {
        throw new Error(`Project "${options.project}" already has a ${options.buildTarget} target. Pass --skipValidation to ignore this error.`);
    }
}
function addBuildTarget(tree, options) {
    (0, add_build_target_defaults_1.addBuildTargetDefaults)(tree, '@nx/rollup:rollup', options.buildTarget);
    const project = (0, devkit_1.readProjectConfiguration)(tree, options.project);
    const packageJsonPath = (0, devkit_1.joinPathFragments)(project.root, 'package.json');
    if (!tree.exists(packageJsonPath)) {
        const importPath = options.importPath || (0, get_import_path_1.getImportPath)(tree, options.project);
        (0, devkit_1.writeJson)(tree, packageJsonPath, {
            name: importPath,
            version: '0.0.1',
        });
    }
    const prevBuildOptions = project.targets?.[options.buildTarget]?.options;
    const buildOptions = {
        main: options.main ??
            prevBuildOptions?.main ??
            (0, devkit_1.joinPathFragments)(project.root, 'src/main.ts'),
        outputPath: prevBuildOptions?.outputPath ??
            (0, devkit_1.joinPathFragments)('dist', project.root === '.' ? project.name : project.root),
        tsConfig: options.tsConfig ??
            prevBuildOptions?.tsConfig ??
            (0, devkit_1.joinPathFragments)(project.root, 'tsconfig.lib.json'),
        additionalEntryPoints: prevBuildOptions?.additionalEntryPoints,
        generateExportsField: prevBuildOptions?.generateExportsField,
        compiler: options.compiler ?? 'babel',
        project: `${project.root}/package.json`,
        external: options.external,
        format: options.format,
    };
    if (options.rollupConfig) {
        buildOptions.rollupConfig = options.rollupConfig;
    }
    if (tree.exists((0, devkit_1.joinPathFragments)(project.root, 'README.md'))) {
        buildOptions.assets = [
            {
                glob: `${project.root}/README.md`,
                input: '.',
                output: '.',
            },
        ];
    }
    (0, devkit_1.updateProjectConfiguration)(tree, options.project, {
        ...project,
        targets: {
            ...project.targets,
            [options.buildTarget]: {
                executor: '@nx/rollup:rollup',
                outputs: ['{options.outputPath}'],
                defaultConfiguration: 'production',
                options: buildOptions,
                configurations: {
                    production: {
                        optimization: true,
                        sourceMap: false,
                        namedChunks: false,
                        extractLicenses: true,
                        vendorChunk: false,
                    },
                },
            },
        },
    });
}
exports.default = configurationGenerator;
