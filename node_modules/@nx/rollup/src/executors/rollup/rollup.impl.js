"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRollupOptions = exports.rollupExecutor = void 0;
const ts = require("typescript");
const rollup = require("rollup");
const plugin_babel_1 = require("@rollup/plugin-babel");
const path_1 = require("path");
const autoprefixer = require("autoprefixer");
const devkit_1 = require("@nx/devkit");
const buildable_libs_utils_1 = require("@nx/js/src/utils/buildable-libs-utils");
const plugin_node_resolve_1 = require("@rollup/plugin-node-resolve");
const type_definitions_1 = require("@nx/js/src/plugins/rollup/type-definitions");
const normalize_1 = require("./lib/normalize");
const analyze_plugin_1 = require("./lib/analyze-plugin");
const fs_1 = require("../../utils/fs");
const swc_plugin_1 = require("./lib/swc-plugin");
const update_package_json_1 = require("./lib/update-package-json");
const config_utils_1 = require("@nx/devkit/src/utils/config-utils");
const async_iterable_1 = require("@nx/devkit/src/utils/async-iterable");
// These use require because the ES import isn't correct.
const commonjs = require('@rollup/plugin-commonjs');
const image = require('@rollup/plugin-image');
const json = require('@rollup/plugin-json');
const copy = require('rollup-plugin-copy');
const postcss = require('rollup-plugin-postcss');
const fileExtensions = ['.js', '.jsx', '.ts', '.tsx'];
async function* rollupExecutor(rawOptions, context) {
    process.env.NODE_ENV ??= 'production';
    const project = context.projectsConfigurations.projects[context.projectName];
    const sourceRoot = project.sourceRoot;
    const { dependencies } = (0, buildable_libs_utils_1.calculateProjectBuildableDependencies)(context.taskGraph, context.projectGraph, context.root, context.projectName, context.targetName, context.configurationName, true);
    const options = (0, normalize_1.normalizeRollupExecutorOptions)(rawOptions, context, sourceRoot);
    const packageJson = (0, devkit_1.readJsonFile)(options.project);
    const npmDeps = (context.projectGraph.dependencies[context.projectName] ?? [])
        .filter((d) => d.target.startsWith('npm:'))
        .map((d) => d.target.slice(4));
    const rollupOptions = await createRollupOptions(options, dependencies, context, packageJson, sourceRoot, npmDeps);
    const outfile = resolveOutfile(context, options);
    if (options.watch) {
        // region Watch build
        return (0, async_iterable_1.createAsyncIterable)(({ next }) => {
            const watcher = rollup.watch(rollupOptions);
            watcher.on('event', (data) => {
                if (data.code === 'START') {
                    devkit_1.logger.info(`Bundling ${context.projectName}...`);
                }
                else if (data.code === 'END') {
                    (0, update_package_json_1.updatePackageJson)(options, packageJson);
                    devkit_1.logger.info('Bundle complete. Watching for file changes...');
                    next({ success: true, outfile });
                }
                else if (data.code === 'ERROR') {
                    devkit_1.logger.error(`Error during bundle: ${data.error.message}`);
                    next({ success: false });
                }
            });
            const processExitListener = (signal) => () => {
                watcher.close();
            };
            process.once('SIGTERM', processExitListener);
            process.once('SIGINT', processExitListener);
            process.once('SIGQUIT', processExitListener);
        });
        // endregion
    }
    else {
        // region Single build
        try {
            devkit_1.logger.info(`Bundling ${context.projectName}...`);
            // Delete output path before bundling
            if (options.deleteOutputPath) {
                (0, fs_1.deleteOutputDir)(context.root, options.outputPath);
            }
            const start = process.hrtime.bigint();
            const allRollupOptions = Array.isArray(rollupOptions)
                ? rollupOptions
                : [rollupOptions];
            for (const opts of allRollupOptions) {
                const bundle = await rollup.rollup(opts);
                const output = Array.isArray(opts.output) ? opts.output : [opts.output];
                for (const o of output) {
                    await bundle.write(o);
                }
            }
            const end = process.hrtime.bigint();
            const duration = `${(Number(end - start) / 1_000_000_000).toFixed(2)}s`;
            (0, update_package_json_1.updatePackageJson)(options, packageJson);
            devkit_1.logger.info(`âš¡ Done in ${duration}`);
            return { success: true, outfile };
        }
        catch (e) {
            if (e.formatted) {
                // Formattted message is provided by Rollup and contains codeframes for where the error occurred.
                devkit_1.logger.info(e.formatted);
            }
            devkit_1.logger.error(e);
            devkit_1.logger.error(`Bundle failed: ${context.projectName}`);
            return { success: false };
        }
        // endregion
    }
}
exports.rollupExecutor = rollupExecutor;
// -----------------------------------------------------------------------------
async function createRollupOptions(options, dependencies, context, packageJson, sourceRoot, npmDeps) {
    const useBabel = options.compiler === 'babel';
    const useSwc = options.compiler === 'swc';
    const tsConfigPath = (0, devkit_1.joinPathFragments)(context.root, options.tsConfig);
    const configFile = ts.readConfigFile(tsConfigPath, ts.sys.readFile);
    const config = ts.parseJsonConfigFileContent(configFile.config, ts.sys, (0, path_1.dirname)(tsConfigPath));
    if (!options.format || !options.format.length) {
        options.format = readCompatibleFormats(config);
    }
    if (packageJson.type === 'module') {
        if (options.format.includes('cjs')) {
            devkit_1.logger.warn(`Package type is set to "module" but "cjs" format is included. Going to use "esm" format instead. You can change the package type to "commonjs" or remove type in the package.json file.`);
        }
        options.format = ['esm'];
    }
    else if (packageJson.type === 'commonjs') {
        if (options.format.includes('esm')) {
            devkit_1.logger.warn(`Package type is set to "commonjs" but "esm" format is included. Going to use "cjs" format instead. You can change the package type to "module" or remove type in the package.json file.`);
        }
        options.format = ['cjs'];
    }
    const plugins = [
        copy({
            targets: convertCopyAssetsToRollupOptions(options.outputPath, options.assets),
        }),
        image(),
        json(),
        // Needed to generate type definitions, even if we're using babel or swc.
        require('rollup-plugin-typescript2')({
            check: !options.skipTypeCheck,
            tsconfig: options.tsConfig,
            tsconfigOverride: {
                compilerOptions: createTsCompilerOptions(config, dependencies, options),
            },
        }),
        (0, type_definitions_1.typeDefinitions)({
            main: options.main,
            projectRoot: options.projectRoot,
        }),
        postcss({
            inject: true,
            extract: options.extractCss,
            autoModules: true,
            plugins: [autoprefixer],
            use: {
                less: {
                    javascriptEnabled: options.javascriptEnabled,
                },
            },
        }),
        (0, plugin_node_resolve_1.default)({
            preferBuiltins: true,
            extensions: fileExtensions,
        }),
        useSwc && (0, swc_plugin_1.swc)(),
        useBabel &&
            (0, plugin_babel_1.getBabelInputPlugin)({
                // Lets `@nx/js/babel` preset know that we are packaging.
                caller: {
                    // @ts-ignore
                    // Ignoring type checks for caller since we have custom attributes
                    isNxPackage: true,
                    // Always target esnext and let rollup handle cjs
                    supportsStaticESM: true,
                    isModern: true,
                },
                cwd: (0, path_1.join)(context.root, sourceRoot),
                rootMode: options.babelUpwardRootMode ? 'upward' : undefined,
                babelrc: true,
                extensions: fileExtensions,
                babelHelpers: 'bundled',
                skipPreflightCheck: true, // pre-flight check may yield false positives and also slows down the build
                exclude: /node_modules/,
            }),
        commonjs(),
        (0, analyze_plugin_1.analyze)(),
    ];
    let externalPackages = [
        ...Object.keys(packageJson.dependencies || {}),
        ...Object.keys(packageJson.peerDependencies || {}),
    ]; // If external is set to none, include all dependencies and peerDependencies in externalPackages
    if (options.external === 'all') {
        externalPackages = externalPackages
            .concat(dependencies.map((d) => d.name))
            .concat(npmDeps);
    }
    else if (Array.isArray(options.external) && options.external.length > 0) {
        externalPackages = externalPackages.concat(options.external);
    }
    externalPackages = [...new Set(externalPackages)];
    const mainEntryFileName = options.outputFileName || options.main;
    const input = {};
    input[(0, path_1.parse)(mainEntryFileName).name] = options.main;
    options.additionalEntryPoints.forEach((entry) => {
        input[(0, path_1.parse)(entry).name] = entry;
    });
    const rollupConfig = {
        input,
        output: options.format.map((format) => ({
            format,
            dir: `${options.outputPath}`,
            name: (0, devkit_1.names)(context.projectName).className,
            entryFileNames: `[name].${format}.js`,
            chunkFileNames: `[name].${format}.js`,
        })),
        external: (id) => {
            return externalPackages.some((name) => id === name || id.startsWith(`${name}/`)); // Could be a deep import
        },
        plugins,
    };
    const userDefinedRollupConfigs = options.rollupConfig.map((plugin) => (0, config_utils_1.loadConfigFile)(plugin));
    let finalConfig = rollupConfig;
    for (const _config of userDefinedRollupConfigs) {
        const config = await _config;
        if (typeof config === 'function') {
            finalConfig = config(finalConfig, options);
        }
        else {
            finalConfig = {
                ...finalConfig,
                ...config,
                plugins: [
                    ...(Array.isArray(finalConfig.plugins) &&
                        finalConfig.plugins?.length > 0
                        ? finalConfig.plugins
                        : []),
                    ...(config.plugins?.length > 0 ? config.plugins : []),
                ],
            };
        }
    }
    return finalConfig;
}
exports.createRollupOptions = createRollupOptions;
function createTsCompilerOptions(config, dependencies, options) {
    const compilerOptionPaths = (0, buildable_libs_utils_1.computeCompilerOptionsPaths)(config, dependencies);
    const compilerOptions = {
        rootDir: options.projectRoot,
        allowJs: options.allowJs,
        declaration: true,
        paths: compilerOptionPaths,
    };
    if (config.options.module === ts.ModuleKind.CommonJS) {
        compilerOptions['module'] = 'ESNext';
    }
    if (options.compiler === 'swc') {
        compilerOptions['emitDeclarationOnly'] = true;
    }
    return compilerOptions;
}
function convertCopyAssetsToRollupOptions(outputPath, assets) {
    return assets
        ? assets.map((a) => ({
            src: (0, path_1.join)(a.input, a.glob).replace(/\\/g, '/'),
            dest: (0, path_1.join)(outputPath, a.output).replace(/\\/g, '/'),
        }))
        : undefined;
}
function readCompatibleFormats(config) {
    switch (config.options.module) {
        case ts.ModuleKind.CommonJS:
        case ts.ModuleKind.UMD:
        case ts.ModuleKind.AMD:
            return ['cjs'];
        default:
            return ['esm'];
    }
}
function resolveOutfile(context, options) {
    if (!options.format?.includes('cjs'))
        return undefined;
    const { name } = (0, path_1.parse)(options.outputFileName ?? options.main);
    return (0, path_1.resolve)(context.root, options.outputPath, `${name}.cjs.js`);
}
exports.default = rollupExecutor;
