{"version":3,"sources":["../../src/swc/compile.ts"],"sourcesContent":["import slash from \"slash\";\nimport { promises } from \"fs\";\nimport { dirname, relative, basename, join } from \"path\";\nimport { transformFile, transformFileSync } from \"@swc/core\";\nimport type { Options, Output } from \"@swc/core\";\n\nconst { mkdir, stat, writeFile } = promises;\n\nfunction withSourceMap(\n    output: Output,\n    options: Options,\n    destFile: string,\n    destDir: string\n) {\n    let dts: string | undefined;\n\n    // TODO: Remove once fixed in core\n    if ((output as any).output) {\n        const json = JSON.parse((output as any).output);\n\n        if (json.__swc_isolated_declarations__) {\n            dts = json.__swc_isolated_declarations__;\n        }\n    }\n\n    let dtsPath: string | undefined;\n\n    if (dts) {\n        dtsPath = join(destDir, basename(destFile) + \".d.ts\");\n    }\n\n    if (!output.map || options.sourceMaps === \"inline\") {\n        return {\n            sourceCode: output.code,\n            dts,\n            dtsPath,\n        };\n    }\n    // TODO: remove once fixed in core https://github.com/swc-project/swc/issues/1388\n    const sourceMap = JSON.parse(output.map);\n    if (options.sourceFileName) {\n        sourceMap[\"sources\"][0] = options.sourceFileName;\n    }\n    if (options.sourceRoot) {\n        sourceMap[\"sourceRoot\"] = options.sourceRoot;\n    }\n    output.map = JSON.stringify(sourceMap);\n\n    const sourceMapPath = destFile + \".map\";\n    output.code += `\\n//# sourceMappingURL=${slash(\n        relative(destDir, sourceMapPath)\n    )}`;\n\n    return {\n        sourceMap: output.map,\n        sourceMapPath,\n        sourceCode: output.code,\n        dts,\n        dtsPath,\n    };\n}\n\nexport async function outputResult(\n    output: Output,\n    sourceFile: string,\n    destFile: string,\n    options: Options\n) {\n    const destDir = dirname(destFile);\n\n    const { sourceMap, sourceMapPath, sourceCode, dts, dtsPath } =\n        withSourceMap(output, options, destFile, destDir);\n\n    await mkdir(destDir, { recursive: true });\n    const { mode } = await stat(sourceFile);\n\n    const dtsPromise = dts\n        ? writeFile(dtsPath!, dts, { mode })\n        : Promise.resolve();\n    const sourceMapPromise = sourceMapPath\n        ? writeFile(sourceMapPath, sourceMap!, { mode })\n        : Promise.resolve();\n\n    await Promise.all([\n        writeFile(destFile, sourceCode, { mode }),\n        dtsPromise,\n        sourceMapPromise,\n    ]);\n}\n\nexport async function compile(\n    filename: string,\n    opts: Options,\n    sync: boolean,\n    outputPath: string | undefined\n): Promise<Output | void> {\n    const options = { ...opts };\n    if (outputPath) {\n        options.outputPath = outputPath;\n    }\n\n    try {\n        const result = sync\n            ? transformFileSync(filename, options)\n            : await transformFile(filename, options);\n\n        return result;\n    } catch (err: any) {\n        if (!err.message.includes(\"ignored by .swcrc\")) {\n            throw err;\n        }\n    }\n}\n"],"names":["compile","outputResult","mkdir","stat","writeFile","promises","withSourceMap","output","options","destFile","destDir","dts","json","JSON","parse","__swc_isolated_declarations__","dtsPath","join","basename","map","sourceMaps","sourceCode","code","sourceMap","sourceFileName","sourceRoot","stringify","sourceMapPath","slash","relative","sourceFile","dirname","recursive","mode","dtsPromise","Promise","resolve","sourceMapPromise","all","filename","opts","sync","outputPath","result","transformFileSync","transformFile","err","message","includes"],"mappings":";;;;;;;;;;;IA0FsBA,OAAO;eAAPA;;IA5BAC,YAAY;eAAZA;;;8DA9DJ;oBACO;sBACyB;sBACD;;;;;;AAGjD,MAAM,EAAEC,KAAK,EAAEC,IAAI,EAAEC,SAAS,EAAE,GAAGC,YAAQ;AAE3C,SAASC,cACLC,MAAc,EACdC,OAAgB,EAChBC,QAAgB,EAChBC,OAAe;IAEf,IAAIC;IAEJ,kCAAkC;IAClC,IAAI,AAACJ,OAAeA,MAAM,EAAE;QACxB,MAAMK,OAAOC,KAAKC,KAAK,CAAC,AAACP,OAAeA,MAAM;QAE9C,IAAIK,KAAKG,6BAA6B,EAAE;YACpCJ,MAAMC,KAAKG,6BAA6B;QAC5C;IACJ;IAEA,IAAIC;IAEJ,IAAIL,KAAK;QACLK,UAAUC,IAAAA,UAAI,EAACP,SAASQ,IAAAA,cAAQ,EAACT,YAAY;IACjD;IAEA,IAAI,CAACF,OAAOY,GAAG,IAAIX,QAAQY,UAAU,KAAK,UAAU;QAChD,OAAO;YACHC,YAAYd,OAAOe,IAAI;YACvBX;YACAK;QACJ;IACJ;IACA,iFAAiF;IACjF,MAAMO,YAAYV,KAAKC,KAAK,CAACP,OAAOY,GAAG;IACvC,IAAIX,QAAQgB,cAAc,EAAE;QACxBD,SAAS,CAAC,UAAU,CAAC,EAAE,GAAGf,QAAQgB,cAAc;IACpD;IACA,IAAIhB,QAAQiB,UAAU,EAAE;QACpBF,SAAS,CAAC,aAAa,GAAGf,QAAQiB,UAAU;IAChD;IACAlB,OAAOY,GAAG,GAAGN,KAAKa,SAAS,CAACH;IAE5B,MAAMI,gBAAgBlB,WAAW;IACjCF,OAAOe,IAAI,IAAI,CAAC,uBAAuB,EAAEM,IAAAA,cAAK,EAC1CC,IAAAA,cAAQ,EAACnB,SAASiB,gBACpB,CAAC;IAEH,OAAO;QACHJ,WAAWhB,OAAOY,GAAG;QACrBQ;QACAN,YAAYd,OAAOe,IAAI;QACvBX;QACAK;IACJ;AACJ;AAEO,eAAef,aAClBM,MAAc,EACduB,UAAkB,EAClBrB,QAAgB,EAChBD,OAAgB;IAEhB,MAAME,UAAUqB,IAAAA,aAAO,EAACtB;IAExB,MAAM,EAAEc,SAAS,EAAEI,aAAa,EAAEN,UAAU,EAAEV,GAAG,EAAEK,OAAO,EAAE,GACxDV,cAAcC,QAAQC,SAASC,UAAUC;IAE7C,MAAMR,MAAMQ,SAAS;QAAEsB,WAAW;IAAK;IACvC,MAAM,EAAEC,IAAI,EAAE,GAAG,MAAM9B,KAAK2B;IAE5B,MAAMI,aAAavB,MACbP,UAAUY,SAAUL,KAAK;QAAEsB;IAAK,KAChCE,QAAQC,OAAO;IACrB,MAAMC,mBAAmBV,gBACnBvB,UAAUuB,eAAeJ,WAAY;QAAEU;IAAK,KAC5CE,QAAQC,OAAO;IAErB,MAAMD,QAAQG,GAAG,CAAC;QACdlC,UAAUK,UAAUY,YAAY;YAAEY;QAAK;QACvCC;QACAG;KACH;AACL;AAEO,eAAerC,QAClBuC,QAAgB,EAChBC,IAAa,EACbC,IAAa,EACbC,UAA8B;IAE9B,MAAMlC,UAAU;QAAE,GAAGgC,IAAI;IAAC;IAC1B,IAAIE,YAAY;QACZlC,QAAQkC,UAAU,GAAGA;IACzB;IAEA,IAAI;QACA,MAAMC,SAASF,OACTG,IAAAA,uBAAiB,EAACL,UAAU/B,WAC5B,MAAMqC,IAAAA,mBAAa,EAACN,UAAU/B;QAEpC,OAAOmC;IACX,EAAE,OAAOG,KAAU;QACf,IAAI,CAACA,IAAIC,OAAO,CAACC,QAAQ,CAAC,sBAAsB;YAC5C,MAAMF;QACV;IACJ;AACJ"}